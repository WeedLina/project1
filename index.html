<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sketch & Smile: The Happy Little Drawing Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, updateDoc, collection, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global variables provided by the Canvas environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // --- GLOBAL GAME STATE & FIREBASE SETUP ---
        let app, db, auth, userId = null;
        let isAuthReady = false;

        setLogLevel('Debug');

        const GAME_STATE_KEY = 'progress';
        const SAVE_COLLECTION_NAME = 'sketch_smile_progress';
        
        // Game Definitions
        const quests = [
            {
                id: 'cloud', title: 'Wobbly Cloud', chapter: 'The Circle Story', steps: [
                    "Draw a gentle curve starting from the left. Don't worry about wobbles; clouds are puffy!",
                    "Complete the curve, connecting back to the start. Use one continuous line, no lifting!",
                    "Add two small, faint circles at the bottom‚Äîthese are just guides for shading later."
                ], guideShape: 'cloud', reward: 'Brush Confidence Badge'
            },
            {
                id: 'apple', title: 'Perfectly Imperfect Apple', chapter: 'The Circle Story', steps: [
                    "Start with a big circle in the middle. If it looks like a potato, congratulations! It‚Äôs your unique apple shape.",
                    "Draw a tiny 'U' shape at the top center for the dent where the stem goes.",
                    "Add a small, short line inside the 'U' for the stem. Keep it light.",
                    "Draw a simple leaf shape next to the stem. Remember, no leaf is identical!"
                ], guideShape: 'circle', reward: 'The Depth Doodler Badge'
            },
            {
                id: 'cat', title: 'Cute Cat Face', chapter: 'The Circle Story', steps: [
                    "Draw a medium circle for the head.",
                    "Add two triangles on top for the ears. Make them slightly rounded.",
                    "Draw a small triangle upside down for the nose and add two curved lines for the mouth.",
                    "Place two almond shapes for the eyes, centered below the horizontal line of your head guide."
                ], guideShape: 'circle', reward: 'Line Master Badge'
            }
        ];

        let state = {
            currentQuestIndex: 0,
            currentStepIndex: 0,
            lineHistory: [],
            erasedCount: 0,
            totalMistakes: 0,
            currentBrushColor: '#4F46E5', // Default Indigo
            currentBrushSize: 4,
            drawingMode: 'pen' // 'pen' or 'eraser'
        };

        // --- FIREBASE FUNCTIONS ---

        const initializeFirebase = async () => {
            try {
                if (Object.keys(firebaseConfig).length === 0) {
                    console.error("Firebase config is missing. Cannot initialize Firestore.");
                    document.getElementById('loading-text').innerText = "Error: Firebase configuration missing. Cannot save progress.";
                    return;
                }
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);

                await authenticateUser();
            } catch (error) {
                console.error("Firebase Initialization Error:", error);
            }
        };

        const authenticateUser = async () => {
            return new Promise((resolve) => {
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                    } else if (initialAuthToken) {
                        try {
                            await signInWithCustomToken(auth, initialAuthToken);
                            userId = auth.currentUser.uid;
                        } catch (e) {
                            console.warn("Custom token sign-in failed. Signing in anonymously.", e);
                            await signInAnonymously(auth);
                            userId = auth.currentUser.uid;
                        }
                    } else {
                        await signInAnonymously(auth);
                        userId = auth.currentUser.uid;
                    }

                    isAuthReady = true;
                    console.log("Authentication complete. User ID:", userId);
                    resolve();
                });
            });
        };

        const getProgressRef = () => {
            if (!userId) return null;
            // Public path for collaborative/shared data (though progress is usually private)
            // Using the private user path for individual progress tracking.
            const docPath = `/artifacts/${appId}/users/${userId}/${SAVE_COLLECTION_NAME}/${GAME_STATE_KEY}`;
            return doc(db, docPath);
        };

        const loadProgress = async () => {
            if (!isAuthReady || !userId) return;

            try {
                const docRef = getProgressRef();
                if (!docRef) return;
                
                const docSnap = await getDoc(docRef);

                if (docSnap.exists()) {
                    const savedState = docSnap.data();
                    // Merge saved state, preserving transient properties like lineHistory
                    state = {
                        ...state, 
                        ...savedState,
                        currentQuestIndex: savedState.currentQuestIndex || 0,
                        currentStepIndex: savedState.currentStepIndex || 0,
                        totalMistakes: savedState.totalMistakes || 0,
                    };
                    console.log("Progress loaded:", state);
                } else {
                    await saveProgress(); // Save initial state if none exists
                }
                updateUI();
                document.getElementById('loading-screen').classList.add('hidden');
                document.getElementById('app-container').classList.remove('hidden');

            } catch (error) {
                console.error("Error loading progress:", error);
                document.getElementById('loading-screen').classList.add('hidden');
                document.getElementById('app-container').classList.remove('hidden');
                document.getElementById('instruction-text').innerText = "Error loading progress. Starting new game.";
            }
        };

        const saveProgress = async () => {
            if (!isAuthReady || !userId) return;

            try {
                const docRef = getProgressRef();
                if (!docRef) return;

                // Only save persistent state variables
                const stateToSave = {
                    currentQuestIndex: state.currentQuestIndex,
                    currentStepIndex: state.currentStepIndex,
                    totalMistakes: state.totalMistakes,
                };

                await setDoc(docRef, stateToSave, { merge: true });
                console.log("Progress saved.");
            } catch (error) {
                console.error("Error saving progress:", error);
            }
        };

        // --- DRAWING TOOL & CANVAS LOGIC ---

        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let currentLine = [];
        let drawingStartTime = 0;
        let lineCount = 0; // Tracks lines drawn in the current step

        const setupCanvas = () => {
            const container = document.getElementById('canvas-container');
            // Set canvas size dynamically
            const resizeCanvas = () => {
                const size = Math.min(container.clientWidth, 600); // Max 600px width/height
                canvas.width = size;
                canvas.height = size;
                redrawCanvas();
            };

            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            // Set initial drawing styles (will be overridden in startDrawing)
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';

            // Event Listeners for drawing
            ['mousedown', 'touchstart'].forEach(event => canvas.addEventListener(event, startDrawing));
            ['mousemove', 'touchmove'].forEach(event => canvas.addEventListener(event, draw));
            ['mouseup', 'mouseout', 'touchend', 'touchcancel'].forEach(event => canvas.addEventListener(event, stopDrawing));

            document.getElementById('clear-btn').addEventListener('click', clearStep);
            
            // Tool Event Listeners
            document.getElementById('color-picker').addEventListener('input', (e) => {
                state.currentBrushColor = e.target.value;
                setDrawingMode('pen');
            });
            document.getElementById('size-slider').addEventListener('input', (e) => {
                state.currentBrushSize = parseInt(e.target.value, 10);
            });
            document.getElementById('pen-btn').addEventListener('click', () => setDrawingMode('pen'));
            document.getElementById('eraser-btn').addEventListener('click', () => setDrawingMode('eraser'));
        };

        const setDrawingMode = (mode) => {
            state.drawingMode = mode;
            // Update button styles to reflect active mode
            document.getElementById('pen-btn').classList.toggle('bg-indigo-600', mode === 'pen');
            document.getElementById('pen-btn').classList.toggle('bg-gray-300', mode !== 'pen');
            document.getElementById('eraser-btn').classList.toggle('bg-indigo-600', mode === 'eraser');
            document.getElementById('eraser-btn').classList.toggle('bg-gray-300', mode !== 'eraser');
        };

        const getCoords = (e) => {
            const rect = canvas.getBoundingClientRect();
            if (e.touches && e.touches.length > 0) {
                return {
                    x: e.touches[0].clientX - rect.left,
                    y: e.touches[0].clientY - rect.top
                };
            }
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        };

        const startDrawing = (e) => {
            e.preventDefault();
            const { x, y } = getCoords(e);
            isDrawing = true;
            lastX = x;
            lastY = y;
            currentLine = [];
            currentLine.push({ x, y });
            drawingStartTime = Date.now();
            lineCount++;
            
            // Set context style based on mode
            ctx.lineWidth = state.currentBrushSize;
            ctx.strokeStyle = state.drawingMode === 'pen' ? state.currentBrushColor : '#FFFFFF'; // White for eraser
            
            // If erasing, use 'destination-out' to erase
            ctx.globalCompositeOperation = state.drawingMode === 'pen' ? 'source-over' : 'destination-out';
        };

        const draw = (e) => {
            if (!isDrawing) return;
            e.preventDefault();
            const { x, y } = getCoords(e);
            
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(x, y);
            ctx.stroke();

            lastX = x;
            lastY = y;
            currentLine.push({ x, y });
        };

        const stopDrawing = () => {
            if (!isDrawing) return;
            isDrawing = false;

            // Reset composite operation
            ctx.globalCompositeOperation = 'source-over';

            if (currentLine.length > 1) {
                // Save the completed line segment and its properties
                state.lineHistory.push({
                    points: currentLine,
                    color: state.currentBrushColor,
                    size: state.currentBrushSize,
                    mode: state.drawingMode
                });
                
                // Redraw all lines to ensure the new segment is persistent, especially after erasing
                redrawCanvas();

                // Update the line counter only if we were in pen mode
                if (state.drawingMode === 'pen') {
                    const penLines = state.lineHistory.filter(line => line.mode === 'pen').length;
                    document.getElementById('lines-drawn-count').innerText = penLines;
                }
            }
        };

        const clearStep = () => {
            if (state.lineHistory.length > 0) {
                state.erasedCount++;
                state.totalMistakes++;
                showMistakePopup("You hit the reset button! Good job simplifying your space. **Sometimes the best drawing starts with a clean slate!**", 'emerald-500');
            }
            // Clear all line history
            state.lineHistory = [];
            redrawCanvas();
            document.getElementById('lines-drawn-count').innerText = 0; // Reset counter display
        };

        const redrawCanvas = () => {
            // Clear the canvas completely first
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw the guide shape
            drawGuideShape(quests[state.currentQuestIndex].guideShape);

            // Re-draw all stored lines
            state.lineHistory.forEach(line => {
                ctx.lineWidth = line.size;
                ctx.strokeStyle = line.mode === 'pen' ? line.color : '#FFFFFF';
                
                // If the line was an 'eraser' action, set composite operation to erase it from the canvas
                ctx.globalCompositeOperation = line.mode === 'pen' ? 'source-over' : 'destination-out';
                
                ctx.beginPath();
                ctx.moveTo(line.points[0].x, line.points[0].y);
                for (let i = 1; i < line.points.length; i++) {
                    ctx.lineTo(line.points[i].x, line.points[i].y);
                }
                ctx.stroke();
            });

            // Reset composite operation for future drawing
            ctx.globalCompositeOperation = 'source-over';
        };
        
        const drawGuideShape = (shape) => {
            const w = canvas.width;
            const h = canvas.height;
            const size = Math.min(w, h) * 0.7;
            const x = w / 2;
            const y = h / 2;
            ctx.strokeStyle = '#D1D5DB'; // Light gray for guide
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);

            if (shape === 'circle') {
                ctx.beginPath();
                ctx.arc(x, y, size / 2, 0, Math.PI * 2);
                ctx.stroke();
            } else if (shape === 'cloud') {
                ctx.beginPath();
                ctx.moveTo(x - size / 2, y);
                ctx.bezierCurveTo(x - size / 2, y - size / 4, x + size / 2, y - size / 4, x + size / 2, y);
                ctx.bezierCurveTo(x + size / 2, y + size / 4, x - size / 2, y + size / 4, x - size / 2, y);
                ctx.stroke();
            }

            ctx.setLineDash([]); // Reset line dash
        };


        // --- GAME MANAGER & UI UPDATES ---

        const updateUI = () => {
            const currentQuest = quests[state.currentQuestIndex];
            if (!currentQuest) return;

            const totalSteps = currentQuest.steps.length;
            const isLastStep = state.currentStepIndex === totalSteps - 1;
            const currentInstruction = currentQuest.steps[state.currentStepIndex];

            // 1. Update Headings
            document.getElementById('quest-chapter').innerText = currentQuest.chapter;
            document.getElementById('quest-title').innerText = currentQuest.title;
            document.getElementById('user-id-display').innerText = `User ID: ${userId.substring(0, 8)}...`;

            // 2. Update Progress
            document.getElementById('progress-bar-fill').style.width = `${((state.currentStepIndex + 1) / totalSteps) * 100}%`;
            document.getElementById('step-counter').innerText = `STEP ${state.currentStepIndex + 1}/${totalSteps}`;
            
            // 3. Update Instruction
            document.getElementById('instruction-text').innerHTML = currentInstruction;

            // 4. Update Button Text
            const nextButton = document.getElementById('next-btn');
            nextButton.innerText = isLastStep ? 'üéâ Finish Quest!' : 'Next Step >';
            
            // 5. Redraw Canvas for the new step
            redrawCanvas();
            
            // Ensure the pen mode is active and the buttons reflect it
            setDrawingMode('pen'); 

            // 6. Reset step variables and update display
            lineCount = 0;
            state.erasedCount = 0;
            // IMPORTANT: We cannot clear lineHistory here, as previous steps must remain visible!
            // state.lineHistory = []; 
            
            // Count existing pen lines for the display (currently 0 because we reset the step logic)
            document.getElementById('lines-drawn-count').innerText = 0; 
        };

        const handleNext = () => {
            const currentQuest = quests[state.currentQuestIndex];
            const totalSteps = currentQuest.steps.length;

            const penLinesDrawn = state.lineHistory.filter(line => line.mode === 'pen').length;
            
            if (penLinesDrawn === 0) {
                 showMistakePopup("Don't skip the magic! You need to draw at least one line before moving on.", 'yellow-500');
                 return;
            }

            // Perform Mistake Check after drawing
            checkHappyMistake();

            if (state.currentStepIndex < totalSteps - 1) {
                // Move to the next step
                state.currentStepIndex++;
                updateUI();
                saveProgress();
            } else {
                // Quest complete!
                handleQuestComplete(currentQuest);
            }
        };

        const handleQuestComplete = (currentQuest) => {
            const nextQuestIndex = state.currentQuestIndex + 1;
            
            const message = nextQuestIndex < quests.length
                ? `You earned the **${currentQuest.reward}**! Get ready for the next challenge: **${quests[nextQuestIndex].title}**!`
                : `You finished the whole chapter! You are a drawing superstar!`;

            showMistakePopup(message, 'indigo-500', true);
            
            // Update state for next quest
            if (nextQuestIndex < quests.length) {
                state.currentQuestIndex = nextQuestIndex;
                state.currentStepIndex = 0;
                // Clear drawing for the new quest
                state.lineHistory = []; 
            } else {
                // If finished all quests, keep the last state for display
                state.currentQuestIndex = quests.length - 1; 
                state.currentStepIndex = 0;
            }

            // Save new progress
            saveProgress();
            
            // Wait for the popup to close before updating the UI fully
            setTimeout(() => {
                 // Clear the canvas one last time for the final reward screen
                 ctx.clearRect(0, 0, canvas.width, canvas.height);
                 updateUI();
            }, 3000); // 3 seconds for the user to read the success message
        };

        const checkHappyMistake = () => {
            // Simple heuristic for a "wobbly" line: Check if the line has too many points for its duration
            const duration = Date.now() - drawingStartTime;
            const pointsPerMs = currentLine.length / (duration || 1);

            if (pointsPerMs > 1.5) {
                state.totalMistakes++;
                showMistakePopup("Slow down, Speedy Doodler! Your line was lightning fast, but maybe too wobbly. **Slow lines make happy shapes!**", 'orange-500');
            } else if (lineCount > 3) {
                state.totalMistakes++;
                showMistakePopup("You drew too many lines for one step! It's okay, sometimes less is more. **Focus on one simple stroke at a time.**", 'purple-500');
            }
        };

        const showMistakePopup = (message, color, isSuccess = false) => {
            const popup = document.getElementById('mistake-popup');
            const iconElement = document.getElementById('popup-icon');
            const titleElement = document.getElementById('popup-title');
            const messageElement = document.getElementById('popup-message');

            const title = isSuccess ? 'QUEST COMPLETE!' : 'ü•≥ Happy Accident Detected!';
            const icon = isSuccess ? 'üèÜ' : '‚ú®';
            
            // Ensure classes are cleared before adding the new background color
            popup.classList.remove('hidden', 'bg-emerald-500', 'bg-orange-500', 'bg-yellow-500', 'bg-purple-500', 'bg-indigo-500');
            popup.classList.add(`bg-${color}`);

            titleElement.innerText = title;
            iconElement.innerText = icon;
            messageElement.innerHTML = message + `<br><br>Total Happy Mistakes: ${state.totalMistakes}`;

            // Automatically close after a delay
            setTimeout(() => {
                popup.classList.add('hidden');
            }, isSuccess ? 3000 : 2500);
        };


        // --- INITIALIZATION ---

        window.onload = async () => {
            await initializeFirebase();
            setupCanvas();
            await loadProgress();
            
            document.getElementById('next-btn').addEventListener('click', handleNext);
        };

    </script>

    <!-- Tailwind Configuration -->
    <style>
        :root {
            font-family: 'Inter', sans-serif;
        }
        canvas {
            touch-action: none; /* Disable default touch actions */
            background-color: #FFFFFF;
            border: 2px solid #E5E7EB;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        }
        /* Custom styling for the color picker to make it smaller/nicer */
        #color-picker {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 8px;
            padding: 0;
            background: transparent;
            cursor: pointer;
        }
        #color-picker::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        #color-picker::-webkit-color-swatch {
            border: 2px solid #D1D5DB;
            border-radius: 8px;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">

    <!-- Loading Screen -->
    <div id="loading-screen" class="fixed inset-0 bg-gray-100 z-50 flex items-center justify-center">
        <div class="text-center">
            <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-500 mx-auto"></div>
            <p id="loading-text" class="mt-4 text-indigo-700 font-semibold">Loading your happy little drawing journey...</p>
        </div>
    </div>


    <!-- Main Application Container -->
    <div id="app-container" class="hidden w-full max-w-4xl bg-white rounded-xl shadow-2xl overflow-hidden md:flex flex-col lg:flex-row h-full max-h-[90vh]">

        <!-- Left Panel: Instructions & Progress -->
        <div class="lg:w-1/3 p-6 flex flex-col justify-between bg-indigo-50 border-r border-gray-200">
            <div>
                <h1 class="text-3xl font-extrabold text-indigo-700 mb-2">Sketch & Smile</h1>
                <p id="user-id-display" class="text-xs text-gray-500 mb-4"></p>
                
                <!-- Quest Info -->
                <div class="mb-6 p-4 bg-white rounded-lg shadow-md border-indigo-200 border">
                    <p id="quest-chapter" class="text-sm font-medium text-indigo-500 uppercase tracking-wider">Chapter 1: The Circle Story</p>
                    <h2 id="quest-title" class="text-xl font-bold text-gray-800 mt-1">Wobbly Cloud</h2>
                </div>

                <!-- Progress Bar -->
                <div class="mb-6">
                    <p id="step-counter" class="text-sm font-semibold text-gray-600 mb-1">STEP 1/3</p>
                    <div class="w-full bg-gray-200 rounded-full h-2.5">
                        <div id="progress-bar-fill" class="bg-indigo-500 h-2.5 rounded-full transition-all duration-500 ease-in-out" style="width: 33.3%;"></div>
                    </div>
                </div>

                <!-- Instruction Box -->
                <div class="p-4 bg-white rounded-lg shadow-md border-green-300 border-l-4">
                    <p class="text-gray-700 font-semibold mb-2">Your Task:</p>
                    <p id="instruction-text" class="text-gray-700">Draw a gentle curve starting from the left. Don't worry about wobbles; clouds are puffy!</p>
                </div>

                <!-- Drawing Tools Section -->
                <div class="mt-6">
                    <h3 class="text-lg font-bold text-gray-700 mb-3">Drawing Tools</h3>
                    <div class="flex flex-wrap items-center gap-4 p-4 bg-white rounded-lg shadow-md">
                        <!-- Pen/Eraser Toggle -->
                        <button id="pen-btn" class="p-2 rounded-lg text-white font-bold transition duration-150 shadow-md bg-indigo-600">
                            ‚úèÔ∏è Pen
                        </button>
                        <button id="eraser-btn" class="p-2 rounded-lg text-gray-700 font-bold transition duration-150 shadow-md bg-gray-300">
                            üßº Eraser
                        </button>
                        
                        <!-- Color Picker -->
                        <div class="flex items-center space-x-2">
                            <input type="color" id="color-picker" value="#4F46E5" class="shadow-md">
                        </div>

                        <!-- Size Slider -->
                        <div class="w-full">
                            <label for="size-slider" class="block text-sm font-medium text-gray-600 mb-1">Brush Size: <span id="current-size-display">4</span>px</label>
                            <input type="range" id="size-slider" min="2" max="20" value="4" class="w-full h-2 bg-indigo-200 rounded-lg appearance-none cursor-pointer" oninput="document.getElementById('current-size-display').innerText=this.value">
                        </div>
                    </div>
                </div>


                <!-- Line Count Feedback -->
                <div class="mt-4 p-4 bg-white rounded-lg shadow-md border-yellow-300 border-l-4 flex items-center justify-between">
                    <p class="text-gray-700 font-semibold">Pen Strokes for this Step:</p>
                    <span id="lines-drawn-count" class="text-xl font-extrabold text-yellow-600">0</span>
                </div>
            </div>

            <!-- Controls -->
            <div class="mt-6 space-y-3">
                <button id="next-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg shadow-lg transition duration-150">
                    Next Step >
                </button>
                <button id="clear-btn" class="w-full bg-red-100 hover:bg-red-200 text-red-700 font-semibold py-3 px-4 rounded-lg transition duration-150">
                    Clear Entire Drawing
                </button>
            </div>
        </div>

        <!-- Right Panel: Canvas Area -->
        <div id="canvas-container" class="lg:w-2/3 p-6 flex items-center justify-center relative">
            <canvas id="drawingCanvas" class="rounded-xl"></canvas>

            <!-- Happy Little Mistake Popup -->
            <div id="mistake-popup" class="hidden absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 p-6 rounded-xl shadow-2xl text-white max-w-xs text-center z-10 transition-all duration-300 ease-in-out">
                <p id="popup-icon" class="text-4xl mb-2">‚ú®</p>
                <h3 id="popup-title" class="text-xl font-bold mb-2">ü•≥ Happy Accident Detected!</h3>
                <p id="popup-message" class="text-sm font-medium">Your line was lightning fast! Slow lines make happy shapes.</p>
            </div>
        </div>

    </div>
</body>
</html>
